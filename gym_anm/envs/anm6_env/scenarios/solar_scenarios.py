import numpy as np
from calendar import isleap
import datetime as dt


class SolarGenerator(object):
    """
    Implements the stochastic generation process of a PV installation.

    The generation of generation profiles is done as follows:
        1.  Each time a new day starts, a "base curve" is generated for the
            next 24h.
        2.  At each time step, random noise is added to the previous power
            generation. The noise is sampled from a normal distribution
            centered on the difference between the previous generation and the
            base curve. This way, the next power generation is more likely to
            get closer to the base curve then it is to get away. Overall,
            the generation profiles follows the pattern given by the base curve.

    Parameters
    ----------
    date : datetime.datetime
        The current time.
    delta_t : int
        The interval of time between subsequent time steps (minutes).
    np_random : numpy.random.RandomState
        The random state of the environment.
    p_max : float
        The maximum real power injection of the find farm (MW).
    base_nf : float
        The noise factor controlling the random noise generated to create the
        base curve of each new day.
    nf : float
        The noise factor controlling the random noise generated at each time
        step. E.g. nf=0 => the generation profile follows the base curve.
    p : float
        The current real power generation factor in [0, 1]. The amount of
        power generated by the wind farm is then p * p_max (MW).
    base : numpy.ndarray
        The base curve for the current day.
    sunrise, sunset : float
        The time of the day of the sunrise and sunset (hours after 00:00).
    """

    def __init__(self, init_date, delta_t, np_random, p_max=1.):
        """
        Parameters
        ----------
        init_date : datetime.datetime
            The time corresponding to time step t=0.
        delta_t : int
            The interval of time between subsequent time steps (minutes).
        np_random : numpy.random.RandomState
            The random state of the environment.
        p_max : float
            The maximum real power generation of the PV installation (MW).
        """

        self.np_random = np_random
        self.p_max = p_max
        self.delta_t = delta_t
        self.date = init_date

        self.base_nf = 0.04
        self.nf = 0.
        self.p = 0.
        self.base = None

    def __iter__(self):
        return self

    def __next__(self):

        # Generate a base curve for every new day at 00:00.
        if self.base is None or (self.date.hour == 0 and self.date.minute == 0):
            T_days = 365 + isleap(self.date.year)
            days_since_1jan = (
                        self.date - dt.datetime(self.date.year, 1, 1)).days
            days_since_solstice = days_since_1jan + 10

            self.base, self.sunrise, self.sunset = \
                self._next_day_base(days_since_solstice, T_days)

        # Time step since 00:00 of the current day.
        timestep = int((self.date.hour * 60 + self.date.minute) / self.delta_t)

        # Compute the difference between the base curve and the previous
        # generation.
        if timestep == self.base.size - 1:
            diff = self.base[0] - self.p
        else:
            diff = self.base[timestep + 1] - self.p

        # Add random noise biased towards the base curve.
        noise = self.np_random.normal(loc=diff, scale=self.nf)
        self.p += noise

        # Clip the generation factor in [0, 1].
        self.p = self._clip_single_production(self.p,
                                              self.date.hour + self.date.minute / 60,
                                              self.sunrise, self.sunset)

        # Increment the date.
        self.date += dt.timedelta(minutes=self.delta_t)

        return self.p * self.p_max

    def next(self):
        return self.__next__()

    def _next_day_base(self, days_since_solstice, T_days):
        """ Compute a new base curve for a new day. """

        # Get the sunrise and sunset times for this day.
        sunrise, sunset = self._sunset_sunrise(days_since_solstice, T_days)

        # Create a bell curve approximating a solar generation daily pattern.
        bell = self._bell_curve(sunrise, sunset)

        # Scale base curve according to the time of the year.
        scaling = self._yearly_pattern(days_since_solstice, T_days)
        base = scaling * bell

        # Add random noise to the base curve.
        base += self.np_random.normal(loc=0., scale=self.base_nf, size=base.size)

        # Clip the base curve to 0 before sunrise and after sunset.
        base = self._clip_base_curve(base, sunrise, sunset)

        return base, sunrise, sunset

    def _sunset_sunrise(self, days_since_solstice, T_days):
        """
        Compute the sunset and sunrise hour, based on the date of the year.
        """

        sunrise = 1.5 * np.cos(2 * np.pi * days_since_solstice / T_days) + 5.5
        sunset = 1.5 * np.cos(2 * np.pi * days_since_solstice / T_days + np.pi) \
                 + 18.5

        return sunrise, sunset

    def _bell_curve(self, sunrise, sunset):
        """
        Return the a deterministic solar generation-like (bell) curve for the day.
        """

        time = np.arange(0, 24, self.delta_t / 60)

        sigma = 2.
        y = np.exp(- (time - 12)**2 / (2 * sigma**2))
        y = self._clip_base_curve(y, sunrise, sunset)

        return y

    def _yearly_pattern(self, days_since_solstice, T_days):
        """
        Return a factor to scale solar generation, based on the day of the year.
        """

        factor = 0.25 * np.cos(2 * np.pi * days_since_solstice / T_days + np.pi) \
                 + 0.75
        return factor

    def _clip_base_curve(self, p, sunrise, sunset):
        """ Clip the base curve to 0 before sunrise and after sunset. """

        time = np.arange(0, 24, self.delta_t / 60)

        p_clipped = np.array(p)
        p_clipped[time < sunrise] = 0
        p_clipped[time > sunset] = 0
        p_clipped[p < 0] = 0

        return p_clipped

    def _clip_single_production(self, p, h, sunrise, sunset):
        """ Clip the generation to 0 if before sunrise or after sunset. """

        if p < 0 or h < sunrise or h > sunset:
            return 0
        else:
            return p


if __name__ == '__main__':
    import matplotlib.pyplot as plt

    rng = np.random.RandomState(2019)
    p_max = 1
    init_date = dt.datetime(2019, 1, 1)
    delta_t = 15
    solar_generator = SolarGenerator(init_date, delta_t, rng, p_max)

    curve = []
    for i_from in range(24 * 4 * 7):
        curve.append(next(solar_generator))

    plt.plot(curve)
    plt.xlabel('Timestep (15 min)')
    plt.ylabel('Solar production')
    plt.title('Generated solar curve over a week')

    plt.show()
